# Стук: Write-up

Нам дан дамп трафика и архив. В архиве мы видим Python-проект `epkp`, который, судя по описанию, содержит `Encrypted Port Knocking Protocol Implementation` — реализацию протокола стучания в порт.

Проект состоит из трёх исходных файлов:

В файле [`ecdhe.py`](app/epkp/ecdhe.py) реализована небольшая обёртка над библиотекой [`cryptography`](https://pypi.org/project/cryptography/) для формирования общего ключа по протоколу Диффи-Хеллмана на эллиптических кривых. Учитывая то, что небиблиотечного кода тут нет, оставим попытки разбираться с ним — достаточно запомнить, что обе стороны в процессе общения формируют неизвестный нам ключ.

В файле [`matrix.py`](app/epkp/matrix.py) находится некий симметричный блочный алгоритм шифрования, который шифрует данные блоками по 16 байт. Самое важное, что можно отметить при первом же взгляде на него — тот факт, что «вектор инициализации» (`self.iv`) переиспользуется при шифровании следующих данных — то есть если подать в шифровальщик две строки, то первая будет зашифрована на изначальном IV, а вторая — на IV, получившемся в результате прошлого шага.

Наконец, в [`client.py`](app/epkp/client.py) мы видим обёртку над Python-модулем [`socket`](https://docs.python.org/3/library/socket.html), которая и реализует шифрование.

По всей видимости, общение должно происходить как-то так:

```python
client = Client("some-host")
client.establish_connection(os.urandom(31))

client.send_encrypted(b"...") # send some data
data = client.recv_encrypted() # receive some data
```

Все данные вариативной длины в протоколе имеют префикс, равный их длине — до момента установления общего ключа это однобайтовый размер сообщения, а после — двухбайтовый размер, но не в байтах, а в блоках шифрования (т.е. 16-байтовое сообщение будет обозначаться меткой размера 01 00).

Здесь же мы узнаём, что упоминаемый в названии port knocking не имеет никакого отношения к [одноимённому способу](https://en.wikipedia.org/wiki/Port_knocking) удалённого управления фаерволлом — название выбрано из-за специфичных констант при общении клиента и сервера. Давайте посмотрим, как устроено общение:

1. Клиент инциаилизирует соединение отправляет серверу 5 байт `45 50 4B 50 FA` и свой публичный ключ (как правило, длиной 133 байта для нашей кривой).

2. Сервер в ответ отправляет 5 байт `45 50 4B 50 FB` и свой публичный ключ.

   На этом обмен ключами ECDH заканчивается, и обе стороны имеют общий ключ.

3. Далее все сообщения по очереди загружаются в один `Encryptor`, отправляется сначала длина зашифрованного сообщения в блоках, затем само сообщение. Отправка и получение сообщений происходят одинаково.

   В качестве вектора инициализации используются первые 16 байт общего ключа, а в качестве ключа — следующие 16 байт. Остальные байты попросту выкидываются.

   Первые два сеанса общения — это приветствие и отправка идентификатора клиента, после чего, сервер, по всей видимости принимает решение о разрешении сессии.

Теперь взглянем на трафик — нетрудно заметить, что единственная TCP-сессия в нём довольно хорошо отражает прочитанное нами. Может смутить, что на третьем шаге длина сообщения и само сообщение почему-то обычно прилетают в отдельных пакетах, но в коде так и написано.

После обмена ключами и подтверждения `client_id` здесь мы видим следующую коммуникацию:

- 7 блоков от клиента к серверу
- 4 блока от сервера к клиенту
- 4 блока от клиента к серверу
- завершение TCP-соединения

Как можно заметить, и сервер, и клиент совместно поддерживают одинаковое состояние `Encryptor`: и при шифровании, и при дешифровании IV «проматывается» одинаковым образом. Давайте посмотрим на это место повнимательнее.

Алгоритм шифрования устроен следующим образом:

1. Сообщение дополняется до размера, кратного 16 байтам (а если оно уже кратно 16 байтам, добавляется целый блок) строкой, состоящий из байтов от 01 до NN, где NN — количество добавляемых байтов.

2. Пункты выполняются по очереди для каждого блока.

3. Сначала IV представляется как матрица 4×4.

4. По очереди для каждого символа ключа берётся его код — 8-битное число — и разделяется на четыре двухбитовых числа `row1`, `row2`, `col1` и `col2`. После этого в матрице IV местами меняются сначала строки `row1` и `row2`, а затем столбцы `col1` и `col2`. Полученный результат записывается в IV.

5. В конце ко всем байтам IV прибавляется единица (если байт был равен 255, он становится равным нулю).

6. Дальше формируется сообщениe IV', в котором все байты IV заменяются с помощью заданного [Sbox](https://ru.wikipedia.org/wiki/S-%D0%B1%D0%BB%D0%BE%D0%BA_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)). Нетрудно узнать, что он взят из алгоритма [Rijndael](https://ru.wikipedia.org/wiki/AES_(%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82_%D1%88%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)), впрочем, это не имеет никакого значения.

7. Блоком шифротекста считается `plaintext XOR IV'`.

8. Полученный IV далее используется для шифрования следующего блока, начиная с пункта 3.

Нам известны два подряд идущие блока в трафике — причём как открытые тексты (из кода), так и шифротексты (из трафика). Это `Knock-knock!` и `Who's there?` — они как раз имеют длину ровно в один блок.

Исходя из этого, мы легко можем восстановить сначала `IV'` в каждом конкретном случае — поксорив шифротекст с открытым текстом, а затем `IV` — применив к нему обратное преобразование к таблице Sbox.

Теперь у нас есть два последовательных значения `IV`, между которыми ровно один раз применили операции из шагов 3, 4 и 5.

Заметим, что на каждом блоке такое преобразование не зависит от текущего состояния IV, плейнтекста и т.д. — к любому входному значению будут применены одни и те же операции. Если мы научимся сами применять к IV эти две операции, то нам не составит труда продолжить поток IV дальше, и расшифровать все остальные блоки.

Для начала давайте вычтем из второго IV единицу и «откатим» шаг 5. Осталось понять, что шаги 3 и 4 лишь переставляют элементы 16-байтного IV в каком-то заранее заданном порядке (который зависит от статичного для всей сессии `key`). 

Разработчики алгоритма заранее о нас позаботились и обеспечили уникальность всех 16 байт IV, поэтому вычислить перестановку получится без труда.

Эту же перестановку можно применить ко второму IV, прибавить единицу и получить следующий IV. Повторяя эту процедуру для каждого последующего блока, мы сможем расшифровать весь трафик.

[Код для решения](app/exploit.py)

Флаг: **ugra_i_know_password_i_see_the_d6a7197bff9e**
